
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-B139P18WHM"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-B139P18WHM');
    </script>
    
    <title>Finding optimal adjustment sets &#8212; DoWhy  documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    <img src="../_static/dowhy-logo-small.png" class="logo__image only-light" alt="Logo image">
    <img src="../_static/dowhy-logo-small.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../getting_started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../user_guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="nb_index.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dowhy.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../contributing.html">
  Contributing
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../code_repo.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        v0.9.1
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
        <dl>
            <dt>Releases</dt>
            <dd><a href="/dowhy/v0.9/index.html">v0.9</a></dd>
            <dd><a href="/dowhy/v0.8/index.html">v0.8</a></dd>
            <dd><a href="/dowhy/v0.7.1/index.html">v0.7.1</a></dd>
            <dd><a href="/dowhy/v0.7/index.html">v0.7</a></dd>
            <dd><a href="/dowhy/v0.6/index.html">v0.6</a></dd>
            <dd><a href="/dowhy/v0.5.1/index.html">v0.5.1</a></dd>
            <dd><a href="/dowhy/v0.5/index.html">v0.5</a></dd>
            <dd><a href="/dowhy/v0.4/index.html">v0.4</a></dd>
            <dd><a href="/dowhy/v0.2/index.html">v0.2</a></dd>
            <dd><a href="/dowhy/v0.1.1-alpha/index.html">v0.1.1-alpha</a></dd>
        </dl>        
        <dl>
            <dt>Branches</dt>
            <dd><a href="">main</a></dd>
        </dl>        
    </div>
</div>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#Preliminaries">
   Preliminaries
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#The-design-of-an-observational-study">
   The design of an observational study
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#An-example-in-which-sufficient-conditions-to-guarantee-the-existence-of-an-optimal-backdoor-set-do-not-hold">
   An example in which sufficient conditions to guarantee the existence of an optimal backdoor set do not hold
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#An-example-in-which-there-are-no-observable-adjustment-sets">
   An example in which there are no observable adjustment sets
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#An-example-with-costs">
   An example with costs
  </a>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<section id="Finding-optimal-adjustment-sets">
<h1>Finding optimal adjustment sets<a class="headerlink" href="#Finding-optimal-adjustment-sets" title="Permalink to this heading"></a></h1>
<section id="Preliminaries">
<h2>Preliminaries<a class="headerlink" href="#Preliminaries" title="Permalink to this heading"></a></h2>
<p>This notebook illustrates the use of the algorithms developed in <a class="reference external" href="https://arxiv.org/abs/1912.00306">Smucler, Sapienza and Rotnitzky (Biometrika, 2022)</a> and <a class="reference external" href="https://www.degruyter.com/document/doi/10.1515/jci-2022-0015/html">Smucler and Rotnitzky (Journal of Causal Inference, 2022)</a> to compute backdoor sets that yield efficient estimators of interventional means and their contrasts (such as the ATE), under various constraints. We begin by recalling some definitions from these papers. We
ommit most technical details, and point the reader to the original papers for them.</p>
<p>The <strong>optimal backdoor set</strong> is a backdoor set comprised of observable variables that yields non-parametric estimators of the interventional mean with the smallest asymptotic variance among those that are based on observable backdoor sets. This optimal backdoor set always exists when no variables are latent, and the algorithm is guaranteed to compute it in this case. Under a non-parametric graphical model with latent variables, such a backdoor set can fail to exist.</p>
<p>The <strong>optimal minimal backdoor set</strong> is a minimal backdoor set comprised of observable variables that yields non-parametric estimators of the interventional mean with the smallest asymptotic variance among those that are based on observable minimal backdoor sets.</p>
<p>The <strong>optimal minimum cost backdoor set</strong> is a minimum cost backdoor set comprised of observable variables that yields non-parametric estimators of the interventional mean with the smallest asymptotic variance among those that are based on observable minimum cost backdoor sets. The cost of a backdoor set is defined as the sum of the costs of the variables that comprise it. Note that when all costs are equal, the optimal minimum cost backdoor set is the optimal backdoor set among those that have
minimum cardinality.</p>
<p>These various optimal backdoor sets are not only optimal under non-parametric graphical models and non-parametric estimators of interventional mean, but also under linear graphical models and OLS estimators, per results in <a class="reference external" href="https://arxiv.org/abs/1907.02435">Henckel, Perkovic and Maathuis (JRSS B, 2022)</a>.</p>
</section>
<section id="The-design-of-an-observational-study">
<h2>The design of an observational study<a class="headerlink" href="#The-design-of-an-observational-study" title="Permalink to this heading"></a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from dowhy.causal_graph import CausalGraph
from dowhy.causal_identifier import AutoIdentifier, BackdoorAdjustment, EstimandType
</pre></div>
</div>
</div>
<p>Consider the design of the following hypothetical observational study discussed in <a class="reference external" href="https://doi.org/10.1186/1471-2288-8-70">Shrier &amp; Platt (2008)</a>. The aim of the study is to assess the effect of warm-up exercises on injury after playing sports. Suppose that a researcher postulates that the graph below represents a causal graphical model. The node warm-up is the treatment variable, which stands for the type of exercise an athlete performs prior to playing sports, and the node injury stands
for the outcome variable.</p>
<p>Suppose that the goal of the study is to estimate and compare the interventional means corresponding to different individualised treatment rules. Each rule prescribes the type of warm-up exercise as a function of previous injury and team motivation. For example, one such rule could be to allocate a patient to perform soft warm-up excercises when she has previous injury = 1 and team motivation &gt; 6, but any other (possibly randomised) function of previous injury and team motivation to set the
treatment variable could be of interest. More formally, the goal of the study is, for some set of policies such as the aforementioned one, to estimate the mean of the outcome, in a world in which all patients are allocated to a treatment variant according to one of these policies. We will suppose moreover that due to practical limitations, the variables genetics, pre-grame proprioception, intra-game proprioception and tissue weakness cannot be measured. Proprioception is an individual’s ability
to sense the movement, action, and location of their own bodies.</p>
<p>To build the graph, we first create a string declaring the graph’s nodes and edges. We then create a list of all observable variables, in this case, all variables in the graph except genetics, pre-game proprioception, intra-game proprioception and tissue weakness. We then pass all this information to the <code class="docutils literal notranslate"><span class="pre">CausalGraph</span></code> class, to create an instance of it.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>graph_str = &quot;&quot;&quot;graph[directed 1 node[id &quot;coach&quot; label &quot;coach&quot;]
                        node[id &quot;team motivation&quot; label &quot;team motivation&quot;]
                        node[id &quot;fitness&quot; label &quot;fitness&quot;]
                        node[id &quot;pre-game prop&quot; label &quot;pre-game prop&quot;]
                        node[id &quot;intra-game prop&quot; label &quot;intra-game prop&quot;]
                        node[id &quot;neuromusc fatigue&quot; label &quot;neuromusc fatigue&quot;]
                        node[id &quot;warm-up&quot; label &quot;warm-up&quot;]
                        node[id &quot;previous injury&quot; label &quot;previous injury&quot;]
                        node[id &quot;contact sport&quot; label &quot;contact sport&quot;]
                        node[id &quot;genetics&quot; label &quot;genetics&quot;]
                        node[id &quot;injury&quot; label &quot;injury&quot;]
                        node[id &quot;tissue disorder&quot; label &quot;tissue disorder&quot;]
                        node[id &quot;tissue weakness&quot; label &quot;tissue weakness&quot;]
                        edge[source &quot;coach&quot; target &quot;team motivation&quot;]
                        edge[source &quot;coach&quot; target &quot;fitness&quot;]
                        edge[source &quot;fitness&quot; target &quot;pre-game prop&quot;]
                        edge[source &quot;fitness&quot; target &quot;neuromusc fatigue&quot;]
                        edge[source &quot;team motivation&quot; target &quot;warm-up&quot;]
                        edge[source &quot;team motivation&quot; target &quot;previous injury&quot;]
                        edge[source &quot;pre-game prop&quot; target &quot;warm-up&quot;]
                        edge[source &quot;warm-up&quot; target &quot;intra-game prop&quot;]
                        edge[source &quot;contact sport&quot; target &quot;previous injury&quot;]
                        edge[source &quot;contact sport&quot; target &quot;intra-game prop&quot;]
                        edge[source &quot;intra-game prop&quot; target &quot;injury&quot;]
                        edge[source &quot;genetics&quot; target &quot;fitness&quot;]
                        edge[source &quot;genetics&quot; target &quot;neuromusc fatigue&quot;]
                        edge[source &quot;genetics&quot; target &quot;tissue disorder&quot;]
                        edge[source &quot;tissue disorder&quot; target &quot;neuromusc fatigue&quot;]
                        edge[source &quot;tissue disorder&quot; target &quot;tissue weakness&quot;]
                        edge[source &quot;neuromusc fatigue&quot; target &quot;intra-game prop&quot;]
                        edge[source &quot;neuromusc fatigue&quot; target &quot;injury&quot;]
                        edge[source &quot;tissue weakness&quot; target &quot;injury&quot;]
                        ]
&quot;&quot;&quot;
observed_node_names = [
    &quot;coach&quot;,
    &quot;team motivation&quot;,
    &quot;fitness&quot;,
    &quot;neuromusc fatigue&quot;,
    &quot;warm-up&quot;,
    &quot;previous injury&quot;,
    &quot;contact sport&quot;,
    &quot;tissue disorder&quot;,
    &quot;injury&quot;,
]
treatment_name = &quot;warm-up&quot;
outcome_name = &quot;injury&quot;
G = CausalGraph(
    graph=graph_str, treatment_name=treatment_name, outcome_name=outcome_name, observed_node_names=observed_node_names
)
</pre></div>
</div>
</div>
<p>We can easily create a plot of the graph using the <code class="docutils literal notranslate"><span class="pre">view_graph</span></code> method.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>G.view_graph()
</pre></div>
</div>
</div>
<p>Next, we illustrate how to compute the backdoor sets defined in the preliminaries section for the example graph above, using the <code class="docutils literal notranslate"><span class="pre">CausalIdentifier</span></code> class. To compute the optimal backdoor set, optimal minimal backdoor set and optimal minimum cost backdoor set, we need to instantiate objects of the <code class="docutils literal notranslate"><span class="pre">CausalIdentifier</span></code> class, passing as <code class="docutils literal notranslate"><span class="pre">method_name</span></code> the values “efficient-adjustment”, “efficient-minimal-adjustment” and “efficient-mincost-adjustment” respectively. Then, we need to call the
<code class="docutils literal notranslate"><span class="pre">identify_effect</span></code> method, passing as an argument a list of conditional nodes, that is, the nodes that would be used to decide how to allocate treatment. As discussed above, in this example these nodes are previous injury and team motivation. For settings in which we are not interested in individualized interventions, we can just pass an empty list as conditional nodes.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>conditional_node_names = [&quot;previous injury&quot;, &quot;team motivation&quot;]
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_EFFICIENT,
)
print(
    ident_eff.identify_effect(
        graph=G, treatment_name=treatment_name, outcome_name=outcome_name, conditional_node_names=conditional_node_names
    )
)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Estimand type: EstimandType.NONPARAMETRIC_ATE

### Estimand : 1
Estimand name: backdoor
Estimand expression:
    d
──────────(E[injury|previous injury,tissue disorder,team motivation,contact sp
d[warm-up]


ort,neuromusc fatigue])

Estimand assumption 1, Unconfoundedness: If U→{warm-up} and U→injury then P(injury|warm-up,previous injury,tissue disorder,team motivation,contact sport,neuromusc fatigue,U) = P(injury|warm-up,previous injury,tissue disorder,team motivation,contact sport,neuromusc fatigue)

### Estimand : 2
Estimand name: iv
No such variable(s) found!

### Estimand : 3
Estimand name: frontdoor
No such variable(s) found!

</pre></div></div>
</div>
<p>Thus, the optimal backdoor set is formed by previous injury, neuromusc fatigue, team motivation, tissue disorder and contact sport.</p>
<p>Similarly, we can compute the optimal minimal backdoor set.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_minimal_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_MIN_EFFICIENT,
)
print(
    ident_minimal_eff.identify_effect(
        graph=G, treatment_name=treatment_name, outcome_name=outcome_name, conditional_node_names=conditional_node_names
    )
)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Estimand type: EstimandType.NONPARAMETRIC_ATE

### Estimand : 1
Estimand name: backdoor
Estimand expression:
    d
──────────(E[injury|team motivation,previous injury,neuromusc fatigue,tissue d
d[warm-up]


isorder])

Estimand assumption 1, Unconfoundedness: If U→{warm-up} and U→injury then P(injury|warm-up,team motivation,previous injury,neuromusc fatigue,tissue disorder,U) = P(injury|warm-up,team motivation,previous injury,neuromusc fatigue,tissue disorder)

### Estimand : 2
Estimand name: iv
No such variable(s) found!

### Estimand : 3
Estimand name: frontdoor
No such variable(s) found!

</pre></div></div>
</div>
<p>Finally, we can compute the optimal minimum cost backdoor set. Since this graph does not have any costs associated with its nodes, we will not pass any costs to <code class="docutils literal notranslate"><span class="pre">identify_effect</span></code>. The method will raise a warning, set the costs to one, and compute the optimal minimum cost backdoor set, which as stated above, in this case coincides with the optimal backdoor set of minimum cardinality.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_mincost_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_MINCOST_EFFICIENT,
)
print(
    ident_mincost_eff.identify_effect(
        graph=G, treatment_name=treatment_name, outcome_name=outcome_name, conditional_node_names=conditional_node_names
    )
)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Estimand type: EstimandType.NONPARAMETRIC_ATE

### Estimand : 1
Estimand name: backdoor
Estimand expression:
    d
──────────(E[injury|fitness,previous injury,team motivation])
d[warm-up]
Estimand assumption 1, Unconfoundedness: If U→{warm-up} and U→injury then P(injury|warm-up,fitness,previous injury,team motivation,U) = P(injury|warm-up,fitness,previous injury,team motivation)

### Estimand : 2
Estimand name: iv
No such variable(s) found!

### Estimand : 3
Estimand name: frontdoor
No such variable(s) found!

</pre></div></div>
</div>
<p>Later, we will compute the optimal minimum cost backdoor set for a graph with costs associated with its nodes.</p>
</section>
<section id="An-example-in-which-sufficient-conditions-to-guarantee-the-existence-of-an-optimal-backdoor-set-do-not-hold">
<h2>An example in which sufficient conditions to guarantee the existence of an optimal backdoor set do not hold<a class="headerlink" href="#An-example-in-which-sufficient-conditions-to-guarantee-the-existence-of-an-optimal-backdoor-set-do-not-hold" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://arxiv.org/abs/1912.00306">Smucler, Sapienza and Rotnitzky (Biometrika, 2022)</a> proved that when all variables are observable, or when all observable variables are ancestors of either the treatment, outcome or conditional nodes, then an optimal backdoor set can be found solely based on the graph, and provided an algorithm to compute it. This is the algorithm implemented in the examples above.</p>
<p>However, there exist cases in which an observable optimal backdoor sets cannot be found solely using graphical criteria. For the graph below, <a class="reference external" href="https://jmlr.csail.mit.edu/papers/volume21/19-1026/19-1026.pdf">Rotnitzky and Smucler (JMLR, 2021)</a> in their Example 5 showed that depending on the law generating the data, the optimal backdoor set could be formed by Z1 and Z2, or be the empty set. More precisely, they showed that there exist probability laws compatible with the graph under which {Z1,
Z2} is the most efficient adjustment set, and other probability laws under which the empty set is the most efficient adjustment set; unfortunately one cannot tell from the graph alone which of the two will be better.</p>
<p>Notice that in this graph, the aforementioned sufficient condition for the existence of an optimal backdoor set does not hold, since Z2 is observable but not an ancestor of treatment outcome or the conditional nodes (the empty set in this case).</p>
<p>On the other hand, <a class="reference external" href="https://arxiv.org/abs/1912.00306">Smucler, Sapienza and Rotnitzky (Biometrika, 2022)</a> showed that optimal minimal and optimal minimum cost (cardinality) observable backdoor sets always exist, as long as there exists at least one backdoor set comprised of observable variables. That is, when the search is restricted to minimal or minimum cost (cardinality) backdoor sets, a situation such as the one described above cannot happen, and the most efficient backdoor set can always
be detected based solely on graphical criteria.</p>
<p>For this example, calling the <code class="docutils literal notranslate"><span class="pre">identify_effect</span></code> method of an instance of <code class="docutils literal notranslate"><span class="pre">CausalIdentifier</span></code> with attribute <code class="docutils literal notranslate"><span class="pre">method_name</span></code> equal to “efficient-adjustment” will raise an error. For this graph, the optimal minimal and the optimal minimum cardinality backdoor sets are equal to the empty set.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>graph_str = &quot;&quot;&quot;graph[directed 1 node[id &quot;X&quot; label &quot;X&quot;]
                        node[id &quot;Y&quot; label &quot;Y&quot;]
                        node[id &quot;Z1&quot; label &quot;Z1&quot;]
                        node[id &quot;Z2&quot; label &quot;Z2&quot;]
                        node[id &quot;U&quot; label &quot;U&quot;]
                        edge[source &quot;X&quot; target &quot;Y&quot;]
                        edge[source &quot;Z1&quot; target &quot;X&quot;]
                        edge[source &quot;Z1&quot; target &quot;Z2&quot;]
                        edge[source &quot;U&quot; target &quot;Z2&quot;]
                        edge[source &quot;U&quot; target &quot;Y&quot;]
                        ]
&quot;&quot;&quot;
observed_node_names = [&quot;X&quot;, &quot;Y&quot;, &quot;Z1&quot;, &quot;Z2&quot;]
treatment_name = &quot;X&quot;
outcome_name = &quot;Y&quot;
G = CausalGraph(
    graph=graph_str, treatment_name=treatment_name, outcome_name=outcome_name, observed_node_names=observed_node_names
)
</pre></div>
</div>
</div>
<p>In this example, the treatment intervention is static, thus there are no conditional nodes.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_EFFICIENT,
)
try:
    results_eff = ident_eff.identify_effect(graph=G, treatment_name=treatment_name, outcome_name=outcome_name)
except ValueError as e:
    print(e)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Conditions to guarantee the existence of an optimal adjustment set are not satisfied
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_MIN_EFFICIENT,
)
print(
    ident_minimal_eff.identify_effect(
        graph=G,
        treatment_name=treatment_name,
        outcome_name=outcome_name,
    )
)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Estimand type: EstimandType.NONPARAMETRIC_ATE

### Estimand : 1
Estimand name: backdoor
Estimand expression:
 d
────(E[Y])
d[X]
Estimand assumption 1, Unconfoundedness: If U→{X} and U→Y then P(Y|X,,U) = P(Y|X,)

### Estimand : 2
Estimand name: iv
Estimand expression:
 ⎡                     -1⎤
 ⎢  d      ⎛  d       ⎞  ⎥
E⎢─────(Y)⋅⎜─────([X])⎟  ⎥
 ⎣d[Z₁]    ⎝d[Z₁]     ⎠  ⎦
Estimand assumption 1, As-if-random: If U→→Y then ¬(U →→{Z1})
Estimand assumption 2, Exclusion: If we remove {Z1}→{X}, then ¬({Z1}→Y)

### Estimand : 3
Estimand name: frontdoor
No such variable(s) found!

</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_MINCOST_EFFICIENT,
)
print(
    ident_mincost_eff.identify_effect(
        graph=G,
        treatment_name=treatment_name,
        outcome_name=outcome_name,
    )
)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Estimand type: EstimandType.NONPARAMETRIC_ATE

### Estimand : 1
Estimand name: backdoor
Estimand expression:
 d
────(E[Y])
d[X]
Estimand assumption 1, Unconfoundedness: If U→{X} and U→Y then P(Y|X,,U) = P(Y|X,)

### Estimand : 2
Estimand name: iv
Estimand expression:
 ⎡                     -1⎤
 ⎢  d      ⎛  d       ⎞  ⎥
E⎢─────(Y)⋅⎜─────([X])⎟  ⎥
 ⎣d[Z₁]    ⎝d[Z₁]     ⎠  ⎦
Estimand assumption 1, As-if-random: If U→→Y then ¬(U →→{Z1})
Estimand assumption 2, Exclusion: If we remove {Z1}→{X}, then ¬({Z1}→Y)

### Estimand : 3
Estimand name: frontdoor
No such variable(s) found!

</pre></div></div>
</div>
</section>
<section id="An-example-in-which-there-are-no-observable-adjustment-sets">
<h2>An example in which there are no observable adjustment sets<a class="headerlink" href="#An-example-in-which-there-are-no-observable-adjustment-sets" title="Permalink to this heading"></a></h2>
<p>In the graph below there are no adjustment sets comprised of only observable variables. In this setting, using any of the above methods will raise an error.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>graph_str = &quot;&quot;&quot;graph[directed 1 node[id &quot;X&quot; label &quot;X&quot;]
                        node[id &quot;Y&quot; label &quot;Y&quot;]
                        node[id &quot;U&quot; label &quot;U&quot;]
                        edge[source &quot;X&quot; target &quot;Y&quot;]
                        edge[source &quot;U&quot; target &quot;X&quot;]
                        edge[source &quot;U&quot; target &quot;Y&quot;]
                        ]
&quot;&quot;&quot;
observed_node_names = [&quot;X&quot;, &quot;Y&quot;]
treatment_name = &quot;X&quot;
outcome_name = &quot;Y&quot;
G = CausalGraph(
    graph=graph_str, treatment_name=treatment_name, outcome_name=outcome_name, observed_node_names=observed_node_names
)
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_EFFICIENT,
)
try:
    results_eff = ident_eff.identify_effect(
        graph=G,
        treatment_name=treatment_name,
        outcome_name=outcome_name,
    )
except ValueError as e:
    print(e)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
An adjustment set formed by observable variables does not exist
</pre></div></div>
</div>
</section>
<section id="An-example-with-costs">
<h2>An example with costs<a class="headerlink" href="#An-example-with-costs" title="Permalink to this heading"></a></h2>
<p>This is the graph in Figures 1 and 2 of <a class="reference external" href="https://www.degruyter.com/document/doi/10.1515/jci-2022-0015/html">Smucler and Rotnitzky (Journal of Causal Inference, 2022)</a>. Here we assume that there are positive costs associated to observable variables.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>graph_str = &quot;&quot;&quot;graph[directed 1 node[id &quot;L&quot; label &quot;L&quot;]
                        node[id &quot;X&quot; label &quot;X&quot;]
                        node[id &quot;K&quot; label &quot;K&quot;]
                        node[id &quot;B&quot; label &quot;B&quot;]
                        node[id &quot;Q&quot; label &quot;Q&quot;]
                        node[id &quot;R&quot; label &quot;R&quot;]
                        node[id &quot;T&quot; label &quot;T&quot;]
                        node[id &quot;M&quot; label &quot;M&quot;]
                        node[id &quot;Y&quot; label &quot;Y&quot;]
                        node[id &quot;U&quot; label &quot;U&quot;]
                        node[id &quot;F&quot; label &quot;F&quot;]
                        edge[source &quot;L&quot; target &quot;X&quot;]
                        edge[source &quot;X&quot; target &quot;M&quot;]
                        edge[source &quot;K&quot; target &quot;X&quot;]
                        edge[source &quot;B&quot; target &quot;K&quot;]
                        edge[source &quot;B&quot; target &quot;R&quot;]
                        edge[source &quot;Q&quot; target &quot;K&quot;]
                        edge[source &quot;Q&quot; target &quot;T&quot;]
                        edge[source &quot;R&quot; target &quot;Y&quot;]
                        edge[source &quot;T&quot; target &quot;Y&quot;]
                        edge[source &quot;M&quot; target &quot;Y&quot;]
                        edge[source &quot;U&quot; target &quot;Y&quot;]
                        edge[source &quot;U&quot; target &quot;F&quot;]
                        ]
                        &quot;&quot;&quot;
observed_node_names = [&quot;L&quot;, &quot;X&quot;, &quot;B&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;M&quot;, &quot;T&quot;, &quot;Y&quot;, &quot;F&quot;]
conditional_node_names = [&quot;L&quot;]
costs = [
    (&quot;L&quot;, {&quot;cost&quot;: 1}),
    (&quot;B&quot;, {&quot;cost&quot;: 1}),
    (&quot;K&quot;, {&quot;cost&quot;: 4}),
    (&quot;Q&quot;, {&quot;cost&quot;: 1}),
    (&quot;R&quot;, {&quot;cost&quot;: 2}),
    (&quot;T&quot;, {&quot;cost&quot;: 1}),
]
G = CausalGraph(
    graph=graph_str, treatment_name=treatment_name, outcome_name=outcome_name, observed_node_names=observed_node_names
)
</pre></div>
</div>
</div>
<p>Notice how in this case we pass both the <code class="docutils literal notranslate"><span class="pre">conditional_node_names</span></code> list and the <code class="docutils literal notranslate"><span class="pre">costs</span></code> list to the <code class="docutils literal notranslate"><span class="pre">identify_effect</span></code> method.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_MINCOST_EFFICIENT,
    costs=costs,
)
print(
    ident_mincost_eff.identify_effect(
        graph=G, treatment_name=treatment_name, outcome_name=outcome_name, conditional_node_names=conditional_node_names
    )
)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Estimand type: EstimandType.NONPARAMETRIC_ATE

### Estimand : 1
Estimand name: backdoor
Estimand expression:
 d
────(E[Y|L,K])
d[X]
Estimand assumption 1, Unconfoundedness: If U→{X} and U→Y then P(Y|X,L,K,U) = P(Y|X,L,K)

### Estimand : 2
Estimand name: iv
Estimand expression:
 ⎡                   -1⎤
 ⎢ d      ⎛ d       ⎞  ⎥
E⎢────(Y)⋅⎜────([X])⎟  ⎥
 ⎣d[L]    ⎝d[L]     ⎠  ⎦
Estimand assumption 1, As-if-random: If U→→Y then ¬(U →→{L})
Estimand assumption 2, Exclusion: If we remove {L}→{X}, then ¬({L}→Y)

### Estimand : 3
Estimand name: frontdoor
Estimand expression:
 ⎡ d       d       ⎤
E⎢────(Y)⋅────([M])⎥
 ⎣d[M]    d[X]     ⎦
Estimand assumption 1, Full-mediation: M intercepts (blocks) all directed paths from X to Y.
Estimand assumption 2, First-stage-unconfoundedness: If U→{X} and U→{M} then P(M|X,U) = P(M|X)
Estimand assumption 3, Second-stage-unconfoundedness: If U→{M} and U→Y then P(Y|M, X, U) = P(Y|M, X)

</pre></div></div>
</div>
<p>We also compute the optimal minimal backdoor set, which in this case is different from the optimal minimum cost backdoor set.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ident_eff = AutoIdentifier(
    estimand_type=EstimandType.NONPARAMETRIC_ATE,
    backdoor_adjustment=BackdoorAdjustment.BACKDOOR_MIN_EFFICIENT,
)
print(
    ident_minimal_eff.identify_effect(
        graph=G, treatment_name=treatment_name, outcome_name=outcome_name, conditional_node_names=conditional_node_names
    )
)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Estimand type: EstimandType.NONPARAMETRIC_ATE

### Estimand : 1
Estimand name: backdoor
Estimand expression:
 d
────(E[Y|L,R,T])
d[X]
Estimand assumption 1, Unconfoundedness: If U→{X} and U→Y then P(Y|X,L,R,T,U) = P(Y|X,L,R,T)

### Estimand : 2
Estimand name: iv
Estimand expression:
 ⎡                   -1⎤
 ⎢ d      ⎛ d       ⎞  ⎥
E⎢────(Y)⋅⎜────([X])⎟  ⎥
 ⎣d[L]    ⎝d[L]     ⎠  ⎦
Estimand assumption 1, As-if-random: If U→→Y then ¬(U →→{L})
Estimand assumption 2, Exclusion: If we remove {L}→{X}, then ¬({L}→Y)

### Estimand : 3
Estimand name: frontdoor
Estimand expression:
 ⎡ d       d       ⎤
E⎢────(Y)⋅────([M])⎥
 ⎣d[M]    d[X]     ⎦
Estimand assumption 1, Full-mediation: M intercepts (blocks) all directed paths from X to Y.
Estimand assumption 2, First-stage-unconfoundedness: If U→{X} and U→{M} then P(M|X,U) = P(M|X)
Estimand assumption 3, Second-stage-unconfoundedness: If U→{M} and U→Y then P(Y|M, X, U) = P(Y|M, X)

</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2022, PyWhy contributors.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>